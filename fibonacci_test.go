package fibonacci

import (
	"testing"
)

func BenchmarkFibonacciOriginal(b *testing.B) {
	for i := 0; i < b.N; i++ {
		FibonacciOriginal(20) // Adjust the input value as needed
	}
}

func BenchmarkFibonacciOptimized(b *testing.B) {
	for i := 0; i < b.N; i++ {
		FibonacciOptimized(20) // Adjust the input value as needed
	}
}

// "37710"과 "25000155"라는 숫자는 벤치마크 결과에서 각각의 벤치마크 함수당 1초에 실행된 작업 횟수(초당 반복 횟수)를 나타냅니다.
// 이러한 숫자들은 벤치마크 동안 코드가 1초 동안 얼마나 많이 실행되었는지를 나타내며, 함수의 성능을 나타냅니다.

// BenchmarkFibonacciOriginal-12 함수는 대략 37,710번의 반복을 1초에 실행했습니다.
// BenchmarkFibonacciOptimized-12 함수는 대략 25,000,155번의 반복을 1초에 실행했습니다.
// 이러한 값들은 다른 구현체들의 상대적인 성능을 비교하는 데에 도움이 될 수 있습니다.
// 이 경우 최적화된 피보나치 함수 구현(FibonacciOptimized)이 월등히 빠르며, 1초에 약 2500만 번의 반복을 수행할 수 있으며,
//  원래의 구현(FibonacciOriginal)은 대략 3만 7,710번의 반복을 1초에 수행할 수 있습니다.

// 이러한 숫자들은 기계의 성능, 부하, 그리고 다른 실행 중인 프로세스 등의 영향을 받아 다른 시스템에서 다를 수 있습니다.
// 그러나 이 값들은 여전히 다른 코드 구현체 또는 최적화의 성능을 비교하는 유용한 방법을 제공합니다. 벤치마크 결과에서는 값이 작을수록(즉, 초당 반복 횟수가 많을수록) 실행 시간이 더 빠른 것을 의미합니다.

// "allocs/op"은 벤치마크 동안 각 작업(반복)당 수행된 평균 메모리 할당 횟수를 나타냅니다. 이 지표는 메모리 할당 동작이 코드의 성능에 어떤 영향을 미칠 수 있는지 이해하는 데 도움이 됩니다.

// BenchmarkFibonacciOriginal-12에서는 평균적으로 작업 당 메모리 할당이 없어서 0 B/op로 표시됩니다. 이는 원래의 구현에서 재귀를 사용하며 실행 중에 새로운 데이터 구조를 생성하지 않기 때문입니다.
// BenchmarkFibonacciOptimized-12에서는 평균적으로 작업 당 176바이트의 메모리 할당이 있어서 176 B/op로 표시됩니다. 이 메모리 할당은 중간 결과를 계산하는 동안 생성된 배열(fib) 때문일 가능성이 있습니다.
// 다음은 이러한 숫자들이 나타내는 바입니다:

// 0 B/op: FibonacciOriginal의 경우, 원래 구현에서는 메모리 할당이 감지되지 않았습니다. 이는 원래 구현이 재귀를 사용하며 실행 중에 새로운 데이터 구조를 생성하지 않기 때문입니다.
// 176 B/op: FibonacciOptimized의 경우, 최적화된 구현에서는 평균적으로 작업 당 176바이트의 메모리 할당이 있었습니다. 이 메모리 할당은 계산 중간 결과를 저장하기 위해 배열(fib)을 생성하는 데 기인할 것입니다.
// "allocs/op"이 낮을수록 좋은데, 이는 코드에서 메모리 할당을 적게 사용한다는 것을 의미하며, 이는 전체적인 성능 향상과 메모리 부담 감소로 이어질 수 있습니다.

// 메모리 할당을 최소화하는 것은 성능에 도움이 되지만, 코드 복잡성과 가독성과의 균형도 고려해야 합니다. 경우에 따라 약간 더 높은 메모리 할당도 허용될 수 있습니다. 이러한 할당이 성능에 큰 향상을 가져온다면 허용할 만한 트레이드오프가 될 수 있습니다.
